# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QassessmentWizardDialog
                                 A QGIS plugin
 Wizard to evaluation assessment
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-12-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by David Torres
        email                : davidt1987@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import (QComboBox, QTableWidgetItem, QToolBar,
                                  QPushButton, QVBoxLayout, QMessageBox,
                                  QProgressDialog)
from qgis.PyQt.QtCore import Qt, QSize, QCoreApplication
from qgis.core import (QgsProject, QgsVectorLayer, QgsWkbTypes,
                       QgsRasterLayer, QgsCoordinateReferenceSystem)
from qgis.gui import QgsMapCanvas, QgsMapToolPan

# Extracted modules (SOLID refactoring)
from .map_tools import FeatureSelectionTool, RectangleSelectTool
from .geometry_utils import (transform_extent_to_canvas_crs,
                              get_assessment_summary)
from .layer_migration import LayerMigrationService
from .assessment_executor import AssessmentExecutor


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'assessment_wizard_dialog_base.ui'))


class QassessmentWizardDialog(QtWidgets.QWizard, FORM_CLASS):
    # Layer status constants
    STATUS_INCLUDE = "Include in assessment"
    STATUS_TARGET = "Include as Target"
    STATUS_SPATIAL_MARKER = "Spatial Marker"
    STATUS_DO_NOT_INCLUDE = "Do not include"

    def __init__(self, parent=None, iface=None, project_id="",
                 admin_manager=None, project_db_id=None):
        """Constructor."""
        super(QassessmentWizardDialog, self).__init__(parent)
        self.setupUi(self)

        # Initialize variables
        self.iface = iface
        self.project_id = project_id
        self.admin_manager = admin_manager
        self.project_db_id = project_db_id
        self.wizard_results = None
        self.target_layer = None
        self.selected_features_layer = None
        self.map_canvas = None
        self.map_canvas_page3 = None
        self.map_tool_select = None

        # Initialize wizard pages
        self.initialize_page_1()
        self.initialize_page_2()
        self.initialize_page_3()

    # ------------------------------------------------------------------ #
    #  Status constants helper
    # ------------------------------------------------------------------ #

    def _status_constants(self):
        """Return status constants as a dict for external modules."""
        return {
            'STATUS_TARGET': self.STATUS_TARGET,
            'STATUS_INCLUDE': self.STATUS_INCLUDE,
            'STATUS_SPATIAL_MARKER': self.STATUS_SPATIAL_MARKER,
            'STATUS_DO_NOT_INCLUDE': self.STATUS_DO_NOT_INCLUDE,
        }

    # ------------------------------------------------------------------ #
    #  Layer collection helpers
    # ------------------------------------------------------------------ #

    def _collect_selected_layers(self):
        """Collect layers that are not 'Do not include' from the table widget.

        Returns:
            dict: {layer_name: QgsVectorLayer}
        """
        layers_dict = {}
        for row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(row, 0)
            status_combo = self.tableWidget_layers.cellWidget(row, 2)

            if layer_name_item and status_combo:
                if status_combo.currentText() != self.STATUS_DO_NOT_INCLUDE:
                    layer_name = layer_name_item.text()
                    layers = QgsProject.instance().mapLayersByName(layer_name)
                    if layers and isinstance(layers[0], QgsVectorLayer):
                        layers_dict[layer_name] = layers[0]
        return layers_dict

    def _collect_target_and_assessment_layers(self):
        """Read table widget to find target and assessment layers.

        Returns:
            tuple: (target_layer: QgsVectorLayer or None,
                    assessment_layers: list[QgsVectorLayer])
        """
        target_layer = None
        assessment_layers = []

        for row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(row, 0)
            status_combo = self.tableWidget_layers.cellWidget(row, 2)

            if layer_name_item and status_combo:
                layer_name = layer_name_item.text()
                status = status_combo.currentText()

                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers and isinstance(layers[0], QgsVectorLayer):
                    if status == self.STATUS_TARGET:
                        target_layer = layers[0]
                    elif status == self.STATUS_INCLUDE:
                        assessment_layers.append(layers[0])

        return target_layer, assessment_layers

    # ------------------------------------------------------------------ #
    #  Wizard lifecycle
    # ------------------------------------------------------------------ #

    def reject(self):
        """Override reject to clean up when user cancels the wizard."""
        self.cleanup_wizard_data()
        super(QassessmentWizardDialog, self).reject()

    def accept(self):
        """Override accept to perform spatial analysis when wizard finishes."""
        assessment_name = self.lineEdit_name.text().strip().replace(' ', '_')
        description = self.textEdit_description.toPlainText().strip()

        executor = AssessmentExecutor(
            self.project_id, self.admin_manager, self.project_db_id
        )

        # Validate name uniqueness
        if not executor.validate_assessment_name(assessment_name):
            QMessageBox.warning(
                self,
                "Duplicate Assessment",
                f"An assessment named '{assessment_name}' already exists in this project.\n\n"
                "Please go back and choose a different name."
            )
            return

        # Gather layers from table widget
        target_layer, assessment_layers = self._collect_target_and_assessment_layers()
        if not target_layer:
            QMessageBox.warning(
                self,
                "Analysis Error",
                "No target layer selected. Please select a layer as 'Include as Target'."
            )
            return

        try:
            # Show progress dialog
            progress = QProgressDialog(
                "Operation and analysis in progress...",
                None, 0, 0, self
            )
            progress.setWindowTitle("Processing")
            progress.setWindowModality(Qt.WindowModal)
            progress.setMinimumDuration(0)
            progress.show()
            QCoreApplication.processEvents()

            # Execute appropriate workflow
            if not assessment_layers:
                self.wizard_results = executor.execute_simple_assessment(
                    assessment_name, target_layer, description,
                    parent_widget=self
                )
            else:
                self.wizard_results = executor.execute_spatial_assessment(
                    assessment_name, target_layer, assessment_layers,
                    description, parent_widget=self
                )

            progress.close()

            if self.wizard_results:
                executor.record_assessment(self.wizard_results)
                self.cleanup_wizard_data()
                super(QassessmentWizardDialog, self).accept()

        except Exception as e:
            progress.close()
            QMessageBox.critical(
                self,
                "Analysis Error",
                f"Spatial analysis failed:\n{str(e)}"
            )

    def get_results(self):
        """Return the structured results after wizard completion."""
        return self.wizard_results

    def cleanup_wizard_data(self):
        """Clean up all data when wizard is cancelled or finished."""
        try:
            if self.selected_features_layer:
                QgsProject.instance().removeMapLayer(self.selected_features_layer.id())
                self.selected_features_layer = None
        except (RuntimeError, AttributeError):
            pass

        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            try:
                self.target_layer.removeSelection()
            except (RuntimeError, AttributeError):
                pass

        self.lineEdit_name.clear()
        self.textEdit_description.clear()

        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 2)
            if combo:
                combo.setCurrentText(self.STATUS_DO_NOT_INCLUDE)

        self.target_layer = None

    # ------------------------------------------------------------------ #
    #  Page 1: Assessment configuration
    # ------------------------------------------------------------------ #

    def initialize_page_1(self):
        """Initialize the first wizard page."""
        self.populate_layers()
        self.page_1.validatePage = self.validate_page_1

    def populate_layers(self):
        """Populate the table widget with vector layers from the 'Base Layers' group folder."""
        self.tableWidget_layers.setRowCount(0)

        root = QgsProject.instance().layerTreeRoot()
        base_layers_group = root.findGroup("Base Layers")

        if not base_layers_group:
            QMessageBox.warning(
                self,
                "Base Layers Not Found",
                "No 'Base Layers' group folder found in the Layers panel.\n\n"
                "Please create a group called 'Base Layers' and add your input layers to it."
            )
            return

        tree_layers = base_layers_group.findLayers()

        for tree_layer in tree_layers:
            layer = tree_layer.layer()

            if not layer or not isinstance(layer, QgsVectorLayer):
                continue

            row_position = self.tableWidget_layers.rowCount()
            self.tableWidget_layers.insertRow(row_position)

            # Column 0: Layer name
            layer_item = QTableWidgetItem(layer.name())
            self.tableWidget_layers.setItem(row_position, 0, layer_item)

            # Column 1: Geometry type
            geometry_type = QgsWkbTypes.displayString(layer.wkbType())
            geometry_item = QTableWidgetItem(geometry_type)
            self.tableWidget_layers.setItem(row_position, 1, geometry_item)

            # Column 2: Status dropdown
            status_combo = QComboBox()
            status_combo.addItems([
                self.STATUS_DO_NOT_INCLUDE,
                self.STATUS_INCLUDE,
                self.STATUS_TARGET,
                self.STATUS_SPATIAL_MARKER
            ])
            status_combo.currentTextChanged.connect(self.on_status_changed)
            self.tableWidget_layers.setCellWidget(row_position, 2, status_combo)

        self.tableWidget_layers.resizeColumnsToContents()

    def on_status_changed(self, text):
        """Handle status change to ensure only one layer is set as Target."""
        if text == self.STATUS_TARGET:
            sender = self.sender()
            for row in range(self.tableWidget_layers.rowCount()):
                combo = self.tableWidget_layers.cellWidget(row, 2)
                if combo and combo != sender and combo.currentText() == self.STATUS_TARGET:
                    combo.setCurrentText(self.STATUS_DO_NOT_INCLUDE)

    def validate_page_1(self):
        """Validate page 1 before allowing user to proceed."""
        if not self.lineEdit_name.text().strip():
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Please enter an assessment name before proceeding."
            )
            return False

        # Check if exactly one layer is set as Target
        target_count = 0
        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 2)
            if combo and combo.currentText() == self.STATUS_TARGET:
                target_count += 1

        if target_count == 0:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Please select exactly one layer as 'Include as Target' before proceeding."
            )
            return False
        elif target_count > 1:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Only one layer can be set as 'Include as Target'. Please check your selections."
            )
            return False

        # Validate geometry types match
        target_layer = None
        target_layer_name = None
        assessment_layers = []

        for row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(row, 0)
            combo = self.tableWidget_layers.cellWidget(row, 2)

            if layer_name_item and combo:
                layer_name = layer_name_item.text()
                status = combo.currentText()

                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers:
                    layer = layers[0]
                    if status == self.STATUS_TARGET:
                        target_layer = layer
                        target_layer_name = layer_name
                    elif status == self.STATUS_INCLUDE:
                        assessment_layers.append((layer_name, layer))

        if target_layer and assessment_layers:
            if isinstance(target_layer, QgsVectorLayer):
                target_geom_type = target_layer.geometryType()

                for assessment_name, assessment_layer in assessment_layers:
                    if isinstance(assessment_layer, QgsVectorLayer):
                        if assessment_layer.geometryType() != target_geom_type:
                            target_type_name = QgsWkbTypes.displayString(target_layer.wkbType())
                            assessment_type_name = QgsWkbTypes.displayString(assessment_layer.wkbType())

                            QtWidgets.QMessageBox.warning(
                                self,
                                "Validation Error",
                                f"Assessment layer '{assessment_name}' has geometry type '{assessment_type_name}', "
                                f"but Target layer '{target_layer_name}' has geometry type '{target_type_name}'.\n\n"
                                f"All selected layers must have the same geometry type."
                            )
                            return False
                    else:
                        QtWidgets.QMessageBox.warning(
                            self,
                            "Validation Error",
                            f"Assessment layer '{assessment_name}' is not a vector layer.\n\n"
                            f"Only vector layers can be used."
                        )
                        return False

        # Migrate selected layers to SpatiaLite
        migration_service = LayerMigrationService(self.admin_manager, self.project_db_id)
        layers_dict = self._collect_selected_layers()
        if not migration_service.migrate_selected_layers(layers_dict, parent_widget=self):
            pass  # Migration failed, but allow user to continue

        return True

    def get_layer_configurations(self):
        """Get the configuration for all layers."""
        configurations = []
        for row in range(self.tableWidget_layers.rowCount()):
            layer_name = self.tableWidget_layers.item(row, 0).text()
            combo = self.tableWidget_layers.cellWidget(row, 2)
            status = combo.currentText() if combo else self.STATUS_DO_NOT_INCLUDE

            configurations.append({
                'layer_name': layer_name,
                'status': status
            })

        return configurations

    # ------------------------------------------------------------------ #
    #  Page 2: Feature selection
    # ------------------------------------------------------------------ #

    def initialize_page_2(self):
        """Initialize the second wizard page."""
        self.currentIdChanged.connect(self.on_page_changed)
        self.pushButton_select_all.clicked.connect(self.select_all_features)
        self.pushButton_clear_selection.clicked.connect(self.clear_selection)
        self.page_2.validatePage = self.validate_page_2

    def on_page_changed(self):
        """Handle page changes to setup page 2 and page 3 when entered."""
        if self.currentPage() == self.page_2:
            self.setup_page_2()
        elif self.currentPage() == self.page_3:
            self.setup_page_3()

    def setup_page_2(self):
        """Setup page 2 with the target layer and map canvas."""
        saved_selection = None
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            saved_selection = list(self.target_layer.selectedFeatureIds())

        self.target_layer = self.get_target_layer()

        if not self.target_layer:
            QtWidgets.QMessageBox.warning(
                self, "Error",
                "No target layer found. Please go back and select a target layer."
            )
            return

        if not isinstance(self.target_layer, QgsVectorLayer):
            QtWidgets.QMessageBox.warning(
                self, "Error",
                "The target layer must be a vector layer. Raster layers are not supported."
            )
            return

        self.label_target_layer_name.setText(f"Target Layer: {self.target_layer.name()}")

        # Create map canvas if it doesn't exist
        if not self.map_canvas:
            self.map_canvas = QgsMapCanvas(self.map_canvas_container)
            self.map_canvas.setCanvasColor(Qt.white)
            self.map_canvas.setMinimumSize(400, 400)
            self.map_canvas.resize(800, 600)

            # Create toolbar for map controls
            self.map_toolbar = QToolBar()
            self.map_toolbar.setIconSize(QSize(16, 16))

            self.zoom_in_button = QPushButton("Zoom In")
            self.zoom_in_button.clicked.connect(self.zoom_in)
            self.map_toolbar.addWidget(self.zoom_in_button)

            self.zoom_out_button = QPushButton("Zoom Out")
            self.zoom_out_button.clicked.connect(self.zoom_out)
            self.map_toolbar.addWidget(self.zoom_out_button)

            self.zoom_full_button = QPushButton("Zoom to Layer")
            self.zoom_full_button.clicked.connect(self.zoom_to_layer)
            self.map_toolbar.addWidget(self.zoom_full_button)

            self.pan_button = QPushButton("Pan")
            self.pan_button.setCheckable(True)
            self.pan_button.clicked.connect(self.toggle_pan)
            self.map_toolbar.addWidget(self.pan_button)

            self.rect_select_button = QPushButton("Rectangle Select")
            self.rect_select_button.setCheckable(True)
            self.rect_select_button.clicked.connect(self.toggle_rectangle_select)
            self.map_toolbar.addWidget(self.rect_select_button)

            self.verticalLayout_map.addWidget(self.map_toolbar)
            self.verticalLayout_map.addWidget(self.map_canvas)

            canvas_crs = QgsCoordinateReferenceSystem("EPSG:3857")
            self.map_canvas.setDestinationCrs(canvas_crs)

            self.map_toolbar.show()
            self.map_canvas.show()
            self.map_canvas_container.show()

        # Setup map with target layer and OpenStreetMap
        osm_layer = self.create_osm_layer()

        self.map_canvas.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:3857"))

        layers_to_display = [self.target_layer]
        if osm_layer and osm_layer.isValid():
            layers_to_display.append(osm_layer)

        self.map_canvas.setLayers([])
        self.map_canvas.setLayers(layers_to_display)

        # Zoom to target layer extent using utility function
        extent = transform_extent_to_canvas_crs(self.map_canvas, self.target_layer)
        self.map_canvas.setExtent(extent)

        self.map_canvas.setCanvasColor(Qt.white)
        self.map_canvas.setRenderFlag(True)
        self.map_canvas.show()
        self.map_canvas_container.show()
        self.map_canvas.refresh()
        QtWidgets.QApplication.processEvents()
        self.map_canvas.repaint()

        # Create and set the custom selection tool
        self.map_tool_select = FeatureSelectionTool(
            self.map_canvas,
            self.target_layer,
            self.update_selection_count
        )
        self.map_canvas.setMapTool(self.map_tool_select)

        # Connect to layer selection changed signal
        if self.target_layer:
            try:
                self.target_layer.selectionChanged.disconnect(self.update_selection_count)
            except:
                pass
            self.target_layer.selectionChanged.connect(self.update_selection_count)

        # Restore saved selection
        if saved_selection and len(saved_selection) > 0:
            self.target_layer.selectByIds(saved_selection)

        self.update_selection_count()

    def create_osm_layer(self):
        """Create an OpenStreetMap base layer."""
        osm_url = "type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png&zmax=19&zmin=0&crs=EPSG:3857"
        osm_layer = QgsRasterLayer(osm_url, "OpenStreetMap", "wms")
        if osm_layer.isValid():
            return osm_layer
        return None

    def get_target_layer(self):
        """Get the layer marked as 'Include as Target' from page 1."""
        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 2)
            if combo and combo.currentText() == self.STATUS_TARGET:
                layer_name = self.tableWidget_layers.item(row, 0).text()
                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers:
                    return layers[0]
        return None

    def select_all_features(self):
        """Select all features in the target layer."""
        if self.target_layer:
            self.target_layer.selectAll()
            self.update_selection_count()

    def clear_selection(self):
        """Clear all selected features in the target layer."""
        if self.target_layer:
            self.target_layer.removeSelection()
            self.update_selection_count()

    def update_selection_count(self):
        """Update the label showing the number of selected features."""
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            count = self.target_layer.selectedFeatureCount()
            self.label_selection_count.setText(f"Selected: {count} features")
            if self.map_canvas:
                self.map_canvas.refresh()

    def validate_page_2(self):
        """Validate page 2 before allowing user to proceed."""
        if not self.target_layer:
            QtWidgets.QMessageBox.warning(
                self, "Validation Error",
                "No target layer is available."
            )
            return False

        if self.target_layer.selectedFeatureCount() == 0:
            QtWidgets.QMessageBox.warning(
                self, "Validation Error",
                "Please select at least one feature before proceeding."
            )
            return False

        # Create new layer with selected features
        selected_ids = list(self.target_layer.selectedFeatureIds())
        if selected_ids:
            expected_layer_name = f"{self.target_layer.name()}_selection"
            should_create_new = True

            try:
                if self.selected_features_layer and self.selected_features_layer.isValid():
                    existing_ids = [f.id() for f in self.selected_features_layer.getFeatures()]
                    if sorted(existing_ids) == sorted(selected_ids):
                        should_create_new = False
            except RuntimeError:
                self.selected_features_layer = None
                should_create_new = True

            if should_create_new:
                existing_layers = QgsProject.instance().mapLayersByName(expected_layer_name)
                for existing_layer in existing_layers:
                    if isinstance(existing_layer, QgsVectorLayer):
                        existing_ids = [f.id() for f in existing_layer.getFeatures()]
                        if sorted(existing_ids) == sorted(selected_ids):
                            self.selected_features_layer = existing_layer
                            should_create_new = False
                            break

            if should_create_new:
                try:
                    if self.selected_features_layer and self.selected_features_layer.isValid():
                        QgsProject.instance().removeMapLayer(self.selected_features_layer.id())
                except RuntimeError:
                    pass

                if self.map_tool_select:
                    self.selected_features_layer = self.map_tool_select.create_layer_from_feature_id(
                        self.target_layer,
                        selected_ids
                    )

                    if self.selected_features_layer and self.selected_features_layer.isValid():
                        QgsProject.instance().addMapLayer(self.selected_features_layer)

        return True

    # ------------------------------------------------------------------ #
    #  Page 3: Summary
    # ------------------------------------------------------------------ #

    def initialize_page_3(self):
        """Initialize the third wizard page."""
        self.tableWidget_summary_layers.setColumnCount(3)
        self.tableWidget_summary_layers.setHorizontalHeaderLabels(
            ["Layer Name", "Geometry Type", "Status"]
        )
        self.tableWidget_summary_layers.horizontalHeader().setStretchLastSection(True)

    def setup_page_3(self):
        """Populate page 3 with summary information."""
        assessment_name = self.lineEdit_name.text().strip()
        assessment_description = self.textEdit_description.toPlainText().strip()

        self.label_summary_name.setText(assessment_name)
        self.label_summary_description.setText(
            assessment_description if assessment_description else "No description provided"
        )

        # Get assessment summary using extracted utility
        summary = get_assessment_summary(
            self.tableWidget_layers, self._status_constants()
        )
        self.label_complexity_summary.setText(summary)

        # Selected feature count
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            feature_count = self.target_layer.selectedFeatureCount()
            self.label_summary_features.setText(f"{feature_count} features selected")
        else:
            self.label_summary_features.setText("0 features selected")

        # Populate layers summary table
        self.tableWidget_summary_layers.setRowCount(0)

        row = 0
        for table_row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(table_row, 0)
            geometry_type_item = self.tableWidget_layers.item(table_row, 1)
            status_combo = self.tableWidget_layers.cellWidget(table_row, 2)

            if layer_name_item and status_combo:
                status = status_combo.currentText()

                if status != self.STATUS_DO_NOT_INCLUDE:
                    self.tableWidget_summary_layers.insertRow(row)

                    name_item = QTableWidgetItem(layer_name_item.text())
                    self.tableWidget_summary_layers.setItem(row, 0, name_item)

                    geometry_item = QTableWidgetItem(
                        geometry_type_item.text() if geometry_type_item else "Unknown"
                    )
                    self.tableWidget_summary_layers.setItem(row, 1, geometry_item)

                    status_item = QTableWidgetItem(status)
                    self.tableWidget_summary_layers.setItem(row, 2, status_item)

                    if status == self.STATUS_TARGET:
                        name_item.setBackground(Qt.gray)
                        geometry_item.setBackground(Qt.gray)
                        status_item.setBackground(Qt.gray)

                    row += 1

        self.tableWidget_summary_layers.resizeColumnsToContents()

        # Setup map canvas for page 3
        if not self.map_canvas_page3:
            self.map_canvas_page3 = QgsMapCanvas(self.widget_map_container_page3)
            self.map_canvas_page3.setCanvasColor(Qt.white)
            self.map_canvas_page3.setMinimumSize(400, 400)
            self.map_canvas_page3.resize(800, 400)

            if not self.widget_map_container_page3.layout():
                layout = QVBoxLayout(self.widget_map_container_page3)
                layout.setContentsMargins(0, 0, 0, 0)
            else:
                layout = self.widget_map_container_page3.layout()

            layout.addWidget(self.map_canvas_page3)

            canvas_crs = QgsCoordinateReferenceSystem("EPSG:3857")
            self.map_canvas_page3.setDestinationCrs(canvas_crs)

            self.map_canvas_page3.show()
            self.widget_map_container_page3.show()
            self.groupBox_selected_features_map.show()

        # Display the selected features layer
        if self.selected_features_layer and self.selected_features_layer.isValid():
            osm_layer = self.create_osm_layer()
            self.map_canvas_page3.setDestinationCrs(
                QgsCoordinateReferenceSystem("EPSG:3857")
            )

            # Get assessment layers for display
            assessment_layers = []
            for table_row in range(self.tableWidget_layers.rowCount()):
                layer_name_item = self.tableWidget_layers.item(table_row, 0)
                status_combo = self.tableWidget_layers.cellWidget(table_row, 2)

                if layer_name_item and status_combo:
                    if status_combo.currentText() == self.STATUS_INCLUDE:
                        layer_name = layer_name_item.text()
                        layers = QgsProject.instance().mapLayersByName(layer_name)
                        if layers and isinstance(layers[0], QgsVectorLayer):
                            assessment_layers.append(layers[0])

            layers_to_display = [self.selected_features_layer]
            layers_to_display.extend(assessment_layers)
            if osm_layer and osm_layer.isValid():
                layers_to_display.append(osm_layer)

            self.map_canvas_page3.setLayers([])
            self.map_canvas_page3.setLayers(layers_to_display)

            # Zoom to selected features using utility function
            extent = transform_extent_to_canvas_crs(
                self.map_canvas_page3, self.selected_features_layer
            )
            self.map_canvas_page3.setExtent(extent)

            self.map_canvas_page3.setRenderFlag(True)
            self.map_canvas_page3.refresh()
            QtWidgets.QApplication.processEvents()
            self.map_canvas_page3.repaint()

    # ------------------------------------------------------------------ #
    #  Map controls
    # ------------------------------------------------------------------ #

    def zoom_in(self):
        """Zoom in on the map canvas."""
        if self.map_canvas:
            self.map_canvas.zoomIn()

    def zoom_out(self):
        """Zoom out on the map canvas."""
        if self.map_canvas:
            self.map_canvas.zoomOut()

    def zoom_to_layer(self):
        """Zoom to the extent of the target layer."""
        if self.map_canvas and self.target_layer:
            extent = transform_extent_to_canvas_crs(self.map_canvas, self.target_layer)
            self.map_canvas.setExtent(extent)
            self.map_canvas.refresh()

    def toggle_pan(self):
        """Toggle pan mode for the map canvas."""
        if self.map_canvas:
            if self.pan_button.isChecked():
                if hasattr(self, 'rect_select_button') and self.rect_select_button.isChecked():
                    self.rect_select_button.setChecked(False)

                if not hasattr(self, 'pan_tool'):
                    self.pan_tool = QgsMapToolPan(self.map_canvas)
                self.map_canvas.setMapTool(self.pan_tool)
            else:
                if self.map_tool_select:
                    self.map_canvas.setMapTool(self.map_tool_select)

    def toggle_rectangle_select(self):
        """Toggle rectangle selection mode for the map canvas."""
        if self.map_canvas:
            if self.rect_select_button.isChecked():
                if hasattr(self, 'pan_button') and self.pan_button.isChecked():
                    self.pan_button.setChecked(False)

                self.rect_select_tool = RectangleSelectTool(
                    self.map_canvas,
                    self.target_layer,
                    self.update_selection_count
                )
                self.map_canvas.setMapTool(self.rect_select_tool)
            else:
                if self.map_tool_select:
                    self.map_canvas.setMapTool(self.map_tool_select)
