# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QassessmentWizardDialog
                                 A QGIS plugin
 Wizard to evaluation assessment
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-12-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by David Torres
        email                : davidt1987@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QComboBox, QTableWidgetItem, QToolBar, QPushButton, QHBoxLayout, QVBoxLayout
from qgis.PyQt.QtCore import Qt, QSize
from qgis.core import (QgsProject, QgsVectorLayer, QgsPointXY, QgsGeometry, QgsWkbTypes, QgsRectangle,
                       QgsRasterLayer, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsFeature, QgsVectorFileWriter)
from qgis.gui import QgsMapCanvas, QgsMapTool, QgsMapToolPan, QgsRubberBand
from PyQt5.QtGui import QColor


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'assessment_wizard_dialog_base.ui'))


class FeatureSelectionTool(QgsMapTool):
    """Custom map tool for selecting features by clicking."""

    def __init__(self, canvas, layer, selection_callback):
        """Initialize the feature selection tool.

        Args:
            canvas: QgsMapCanvas - The map canvas
            layer: QgsVectorLayer - The layer to select features from
            selection_callback: callable - Function to call when selection changes
        """
        super(FeatureSelectionTool, self).__init__(canvas)
        self.layer = layer
        self.selection_callback = selection_callback
        self.setCursor(Qt.CrossCursor)
    
    def create_layer_from_feature_id(self, source_layer, feature_ids):
        """Create a new memory layer from selected feature IDs.

        Args:
            source_layer: QgsVectorLayer - The source layer
            feature_ids: list - List of feature IDs to copy

        Returns:
            QgsVectorLayer - New memory layer with selected features
        """
        from qgis.core import QgsWkbTypes

        # Commented out - Old code not needed for memory layer creation
        # request = QgsFeatureRequest().setFilterFid(feature_ids)
        # safe_options = QgsVectorFileWriter.SaveVectorOptions()
        # safe_options.driverName = "SQLite"
        # safe_options.layerName = table_name
        # safe_options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        # safe_options.fileEncoding = "UTF-8"
        # safe_options.datasourceOptions = ["SPATIALITE=YES"]
        
        # Get layer properties
        geometry_type = source_layer.geometryType()
        crs = source_layer.crs().authid()
        layer_name = f"{source_layer.name()}_selection"

        # Create new memory layer with proper URI format
        new_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(source_layer.wkbType())}?crs={crs}", layer_name, "memory")

        # Verify layer was created successfully
        if not new_layer.isValid():
            return None

        # Copy fields from source layer
        new_layer.dataProvider().addAttributes(source_layer.fields())
        new_layer.updateFields()

        # Copy features from source layer
        features = []
        for fid in feature_ids:
            feature = source_layer.getFeature(fid)
            if feature.isValid():
                features.append(feature)

        # Add features to new layer
        if features:
            new_layer.dataProvider().addFeatures(features)
            new_layer.updateExtents()

        return new_layer

    def canvasReleaseEvent(self, event):
        """Handle mouse click on the map canvas with CRS transformation."""
        from qgis.core import QgsFeatureRequest

        # Get the click point in map coordinates
        point = self.toMapCoordinates(event.pos())

        # Calculate search tolerance based on map scale (5 pixels)
        search_radius = self.canvas().mapUnitsPerPixel() * 5

        # Transform point to layer CRS if needed
        layer_point = point
        layer_search_radius = search_radius

        if self.canvas().mapSettings().destinationCrs() != self.layer.crs():
            transform = QgsCoordinateTransform(
                self.canvas().mapSettings().destinationCrs(),
                self.layer.crs(),
                QgsProject.instance()
            )
            layer_point = transform.transform(point)

            # Transform the search radius (approximate)
            # Create a small rectangle and transform it to get the transformed radius
            test_point = QgsPointXY(point.x() + search_radius, point.y())
            transformed_test = transform.transform(test_point)
            layer_search_radius = layer_point.distance(transformed_test)

        # Create a point geometry for distance calculation in layer CRS
        point_geom = QgsGeometry.fromPointXY(QgsPointXY(layer_point))

        # Create search rectangle for efficient spatial filtering
        search_rect = QgsRectangle(
            layer_point.x() - layer_search_radius,
            layer_point.y() - layer_search_radius,
            layer_point.x() + layer_search_radius,
            layer_point.y() + layer_search_radius
        )

        # Use spatial filter for efficient querying
        request = QgsFeatureRequest()
        request.setFilterRect(search_rect)

        # Find features and calculate distances in layer CRS
        candidates = []
        for feature in self.layer.getFeatures(request):
            geom = feature.geometry()
            if geom and not geom.isNull():
                distance = geom.distance(point_geom)
                if distance <= layer_search_radius:
                    candidates.append((feature.id(), distance))

        # Sort by distance to get the closest feature
        candidates.sort(key=lambda x: x[1])

        if candidates:
            # Get current selection
            selected_ids = set(self.layer.selectedFeatureIds())

            # Toggle selection for the closest feature
            clicked_id = candidates[0][0]
            if clicked_id in selected_ids:
                selected_ids.discard(clicked_id)
            else:
                selected_ids.add(clicked_id)

            # Update layer selection
            self.layer.selectByIds(list(selected_ids))

            # Refresh canvas to show selection
            self.canvas().refresh()

            # Trigger callback to update UI
            if self.selection_callback:
                self.selection_callback()


class RectangleSelectTool(QgsMapTool):
    """Custom map tool for selecting features with a rectangle."""

    def __init__(self, canvas, target_layer=None, selection_callback=None):
        """Initialize the rectangle selection tool.

        Args:
            canvas: QgsMapCanvas - The map canvas
            target_layer: QgsVectorLayer - The layer to select features from (optional)
            selection_callback: callable - Function to call when selection changes
        """
        super(RectangleSelectTool, self).__init__(canvas)
        self.canvas = canvas
        self.target_layer = target_layer
        self.selection_callback = selection_callback
        self.rubber_band = QgsRubberBand(canvas, QgsWkbTypes.PolygonGeometry)
        self.rubber_band.setColor(QColor(255, 0, 0, 100))  # Semi-transparent red
        self.rubber_band.setWidth(2)
        self.start_point = None
        self.end_point = None
        self.setCursor(Qt.CrossCursor)

    def canvasPressEvent(self, event):
        """Handle mouse press event."""
        if event.button() == Qt.LeftButton:
            self.start_point = self.toMapCoordinates(event.pos())
            self.end_point = self.start_point
            self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)

    def canvasMoveEvent(self, event):
        """Handle mouse move event to update rubber band."""
        if self.start_point is None:
            return
        self.end_point = self.toMapCoordinates(event.pos())
        self.update_rubber_band()

    def canvasReleaseEvent(self, event):
        """Handle mouse release event to select features (rectangle or point)."""
        if event.button() != Qt.LeftButton or self.start_point is None:
            return

        self.end_point = self.toMapCoordinates(event.pos())
        self.update_rubber_band()

        # Create rectangle from start and end points
        rect = QgsRectangle(self.start_point, self.end_point)

        # Check if this is a single click (point selection) or a rectangle drag
        is_single_click = rect.isEmpty() or (
            abs(self.start_point.x() - self.end_point.x()) < self.canvas.mapUnitsPerPixel() * 3 and
            abs(self.start_point.y() - self.end_point.y()) < self.canvas.mapUnitsPerPixel() * 3
        )

        from qgis.core import QgsFeatureRequest

        additive = event.modifiers() & Qt.ShiftModifier  # Hold Shift to add to selection

        # Use target layer if specified, otherwise use all visible vector layers
        if self.target_layer:
            layers = [self.target_layer]
        else:
            layers = [layer for layer in self.canvas.layers()
                     if isinstance(layer, QgsVectorLayer)]

        for layer in layers:
            if not layer or not isinstance(layer, QgsVectorLayer):
                continue

            if is_single_click:
                # Handle point selection
                point = self.end_point
                search_radius = self.canvas.mapUnitsPerPixel() * 5

                # Transform point to layer CRS if needed
                layer_point = point
                layer_search_radius = search_radius

                if self.canvas.mapSettings().destinationCrs() != layer.crs():
                    transform = QgsCoordinateTransform(
                        self.canvas.mapSettings().destinationCrs(),
                        layer.crs(),
                        QgsProject.instance()
                    )
                    layer_point = transform.transform(point)
                    test_point = QgsPointXY(point.x() + search_radius, point.y())
                    transformed_test = transform.transform(test_point)
                    layer_search_radius = layer_point.distance(transformed_test)

                # Create search rectangle for point selection
                point_geom = QgsGeometry.fromPointXY(QgsPointXY(layer_point))
                search_rect = QgsRectangle(
                    layer_point.x() - layer_search_radius,
                    layer_point.y() - layer_search_radius,
                    layer_point.x() + layer_search_radius,
                    layer_point.y() + layer_search_radius
                )

                # Find closest feature
                request = QgsFeatureRequest()
                request.setFilterRect(search_rect)

                candidates = []
                for feature in layer.getFeatures(request):
                    geom = feature.geometry()
                    if geom and not geom.isNull():
                        distance = geom.distance(point_geom)
                        if distance <= layer_search_radius:
                            candidates.append((feature.id(), distance))

                candidates.sort(key=lambda x: x[1])

                if candidates:
                    # Always add to selection for point clicks (additive behavior)
                    existing_ids = set(layer.selectedFeatureIds())
                    clicked_id = candidates[0][0]

                    # Toggle: if already selected, remove it; otherwise add it
                    if clicked_id in existing_ids:
                        existing_ids.discard(clicked_id)
                    else:
                        existing_ids.add(clicked_id)

                    layer.selectByIds(list(existing_ids))
            else:
                # Handle rectangle selection
                # Transform rectangle to layer CRS if needed
                layer_rect = rect
                if self.canvas.mapSettings().destinationCrs() != layer.crs():
                    transform = QgsCoordinateTransform(
                        self.canvas.mapSettings().destinationCrs(),
                        layer.crs(),
                        QgsProject.instance()
                    )
                    layer_rect = transform.transformBoundingBox(rect)

                # Create feature request with rectangle filter in layer CRS
                request = QgsFeatureRequest()
                request.setFilterRect(layer_rect)

                # Get feature IDs that intersect with the rectangle
                rect_geom = QgsGeometry.fromRect(layer_rect)
                new_feature_ids = []

                for feature in layer.getFeatures(request):
                    if feature.geometry() and feature.geometry().intersects(rect_geom):
                        new_feature_ids.append(feature.id())

                if additive:
                    # Shift pressed: Add to existing selection
                    existing_ids = set(layer.selectedFeatureIds())
                    for fid in new_feature_ids:
                        if fid not in existing_ids:
                            existing_ids.add(fid)
                    layer.selectByIds(list(existing_ids))
                else:
                    # Shift not pressed: Replace selection
                    layer.selectByIds(new_feature_ids)

        # Reset tool
        self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
        self.start_point = None
        self.end_point = None

        # Refresh canvas to show selection
        self.canvas.refresh()

        # Trigger callback to update UI after refresh
        if self.selection_callback:
            self.selection_callback()

    def update_rubber_band(self):
        """Update the rubber band rectangle visualization."""
        self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
        if self.start_point and self.end_point:
            # Create rectangle points
            points = [
                self.start_point,
                QgsPointXY(self.start_point.x(), self.end_point.y()),
                self.end_point,
                QgsPointXY(self.end_point.x(), self.start_point.y())
            ]
            for i, point in enumerate(points):
                self.rubber_band.addPoint(point, True if i == len(points) - 1 else False)
            self.rubber_band.show()

    def deactivate(self):
        """Clean up when tool is deactivated."""
        self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
        super(RectangleSelectTool, self).deactivate()


class QassessmentWizardDialog(QtWidgets.QWizard, FORM_CLASS):
    # Layer status constants
    STATUS_INCLUDE = "Include in assessment"
    STATUS_TARGET = "Include as Target"
    STATUS_SPATIAL_MARKER = "Spatial Marker"
    STATUS_DO_NOT_INCLUDE = "Do not include"

    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(QassessmentWizardDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Initialize variables
        self.iface = iface
        self.target_layer = None
        self.selected_features_layer = None
        self.map_canvas = None
        self.map_canvas_page3 = None
        self.map_tool_select = None

        # Initialize wizard pages
        self.initialize_page_1()
        self.initialize_page_2()
        self.initialize_page_3()

    def reject(self):
        """Override reject to clean up when user cancels the wizard."""
        self.cleanup_wizard_data()
        super(QassessmentWizardDialog, self).reject()

    def cleanup_wizard_data(self):
        """Clean up all data when wizard is cancelled or finished."""
        # Remove the selected features layer from project if it exists
        try:
            if self.selected_features_layer:
                QgsProject.instance().removeMapLayer(self.selected_features_layer.id())
                self.selected_features_layer = None
        except (RuntimeError, AttributeError):
            # Layer was already deleted or doesn't exist
            pass

        # Clear selection on target layer
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            try:
                self.target_layer.removeSelection()
            except (RuntimeError, AttributeError):
                pass

        # Clear page 1 inputs
        self.lineEdit_name.clear()
        self.textEdit_description.clear()

        # Reset all layer status combos to "Do not include"
        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 1)
            if combo:
                combo.setCurrentText(self.STATUS_DO_NOT_INCLUDE)

        # Reset internal references
        self.target_layer = None

    def initialize_page_1(self):
        """Initialize the first wizard page."""
        # Page 1 contains name and description fields
        # Access them using:
        # - self.lineEdit_name
        # - self.textEdit_description
        # - self.tableWidget_layers

        # Populate the layer table with available layers from QGIS
        self.populate_layers()

        # Set up page validation
        self.page_1.validatePage = self.validate_page_1

    def populate_layers(self):
        """Populate the table widget with available layers from the QGIS project."""
        self.tableWidget_layers.setRowCount(0)

        # Get all layers from the current QGIS project
        layers = QgsProject.instance().mapLayers().values()

        # Add each layer to the table with a status dropdown
        # Only include vector layers (raster layers cannot be used as target)
        for layer in layers:
            # Check if it's a vector layer
            if not isinstance(layer, QgsVectorLayer):
                continue

            row_position = self.tableWidget_layers.rowCount()
            self.tableWidget_layers.insertRow(row_position)

            # Column 0: Layer name
            layer_item = QTableWidgetItem(layer.name())
            self.tableWidget_layers.setItem(row_position, 0, layer_item)

            # Column 1: Status dropdown
            status_combo = QComboBox()
            status_combo.addItems([
                self.STATUS_DO_NOT_INCLUDE,
                self.STATUS_INCLUDE,
                self.STATUS_TARGET,
                self.STATUS_SPATIAL_MARKER
            ])
            status_combo.currentTextChanged.connect(self.on_status_changed)
            self.tableWidget_layers.setCellWidget(row_position, 1, status_combo)

        # Resize columns to fit content
        self.tableWidget_layers.resizeColumnsToContents()

    def on_status_changed(self, text):
        """Handle status change to ensure only one layer is set as Target."""
        if text == self.STATUS_TARGET:
            # Get the sender combo box
            sender = self.sender()

            # Find all combo boxes and reset any other "Include as Target" to "Do not include"
            for row in range(self.tableWidget_layers.rowCount()):
                combo = self.tableWidget_layers.cellWidget(row, 1)
                if combo and combo != sender and combo.currentText() == self.STATUS_TARGET:
                    combo.setCurrentText(self.STATUS_DO_NOT_INCLUDE)

    def validate_page_1(self):
        """Validate page 1 before allowing user to proceed."""
        # Check if assessment name is provided
        if not self.lineEdit_name.text().strip():
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Please enter an assessment name before proceeding."
            )
            return False

        # Check if exactly one layer is set as "Include as Target"
        target_count = 0
        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 1)
            if combo and combo.currentText() == self.STATUS_TARGET:
                target_count += 1

        if target_count == 0:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Please select exactly one layer as 'Include as Target' before proceeding."
            )
            return False
        elif target_count > 1:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Only one layer can be set as 'Include as Target'. Please check your selections."
            )
            return False

        # Validate that Spatial Marker layers have the same geometry type as Target layer
        target_layer = None
        target_layer_name = None
        spatial_marker_layers = []

        # Find the target layer and spatial marker layers
        for row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(row, 0)
            combo = self.tableWidget_layers.cellWidget(row, 1)

            if layer_name_item and combo:
                layer_name = layer_name_item.text()
                status = combo.currentText()

                # Get the actual layer from QGIS project
                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers:
                    layer = layers[0]

                    if status == self.STATUS_TARGET:
                        target_layer = layer
                        target_layer_name = layer_name
                    elif status == self.STATUS_SPATIAL_MARKER:
                        spatial_marker_layers.append((layer_name, layer))

        # Check if spatial marker layers have the same geometry type as target
        if target_layer and spatial_marker_layers:
            if isinstance(target_layer, QgsVectorLayer):
                target_geom_type = target_layer.geometryType()

                for marker_name, marker_layer in spatial_marker_layers:
                    if isinstance(marker_layer, QgsVectorLayer):
                        if marker_layer.geometryType() != target_geom_type:
                            # Get human-readable geometry type names
                            target_type_name = QgsWkbTypes.displayString(target_layer.wkbType())
                            marker_type_name = QgsWkbTypes.displayString(marker_layer.wkbType())

                            QtWidgets.QMessageBox.warning(
                                self,
                                "Validation Error",
                                f"Spatial Marker layer '{marker_name}' has geometry type '{marker_type_name}', "
                                f"but Target layer '{target_layer_name}' has geometry type '{target_type_name}'.\n\n"
                                f"All Spatial Marker layers must have the same geometry type as the Target layer."
                            )
                            return False
                    else:
                        QtWidgets.QMessageBox.warning(
                            self,
                            "Validation Error",
                            f"Spatial Marker layer '{marker_name}' is not a vector layer.\n\n"
                            f"Only vector layers can be used as Spatial Markers."
                        )
                        return False

        return True

    def get_layer_configurations(self):
        """Get the configuration for all layers."""
        configurations = []
        for row in range(self.tableWidget_layers.rowCount()):
            layer_name = self.tableWidget_layers.item(row, 0).text()
            combo = self.tableWidget_layers.cellWidget(row, 1)
            status = combo.currentText() if combo else self.STATUS_DO_NOT_INCLUDE

            configurations.append({
                'layer_name': layer_name,
                'status': status
            })

        return configurations

    def initialize_page_2(self):
        """Initialize the second wizard page."""
        # Connect page entered signal to setup the map
        self.currentIdChanged.connect(self.on_page_changed)

        # Connect selection buttons
        self.pushButton_select_all.clicked.connect(self.select_all_features)
        self.pushButton_clear_selection.clicked.connect(self.clear_selection)

        # Set up page validation
        self.page_2.validatePage = self.validate_page_2

    def on_page_changed(self):
        """Handle page changes to setup page 2 and page 3 when entered."""
        if self.currentPage() == self.page_2:
            self.setup_page_2()
        elif self.currentPage() == self.page_3:
            self.setup_page_3()

    def setup_page_2(self):
        """Setup page 2 with the target layer and map canvas."""
        # Save current selection if target layer already exists (user is coming back from page 3)
        saved_selection = None
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            saved_selection = list(self.target_layer.selectedFeatureIds())

        # Get the target layer from page 1
        self.target_layer = self.get_target_layer()

        if not self.target_layer:
            QtWidgets.QMessageBox.warning(
                self,
                "Error",
                "No target layer found. Please go back and select a target layer."
            )
            return

        # Verify it's a vector layer
        if not isinstance(self.target_layer, QgsVectorLayer):
            QtWidgets.QMessageBox.warning(
                self,
                "Error",
                "The target layer must be a vector layer. Raster layers are not supported."
            )
            return

        # Update the label with target layer name
        self.label_target_layer_name.setText(f"Target Layer: {self.target_layer.name()}")

        # Create map canvas if it doesn't exist
        if not self.map_canvas:
            # Use map_canvas_container as parent for proper layout
            self.map_canvas = QgsMapCanvas(self.map_canvas_container)
            self.map_canvas.setCanvasColor(Qt.white)

            # Set size for the canvas
            self.map_canvas.setMinimumSize(400, 400)
            self.map_canvas.resize(800, 600)

            # Create toolbar for map controls
            self.map_toolbar = QToolBar()
            self.map_toolbar.setIconSize(QSize(16, 16))

            # Zoom In button
            self.zoom_in_button = QPushButton("Zoom In")
            self.zoom_in_button.clicked.connect(self.zoom_in)
            self.map_toolbar.addWidget(self.zoom_in_button)

            # Zoom Out button
            self.zoom_out_button = QPushButton("Zoom Out")
            self.zoom_out_button.clicked.connect(self.zoom_out)
            self.map_toolbar.addWidget(self.zoom_out_button)

            # Zoom to Full Extent button
            self.zoom_full_button = QPushButton("Zoom to Layer")
            self.zoom_full_button.clicked.connect(self.zoom_to_layer)
            self.map_toolbar.addWidget(self.zoom_full_button)

            # Pan button
            self.pan_button = QPushButton("Pan")
            self.pan_button.setCheckable(True)
            self.pan_button.clicked.connect(self.toggle_pan)
            self.map_toolbar.addWidget(self.pan_button)

            # Rectangle Select button
            self.rect_select_button = QPushButton("Rectangle Select")
            self.rect_select_button.setCheckable(True)
            self.rect_select_button.clicked.connect(self.toggle_rectangle_select)
            self.map_toolbar.addWidget(self.rect_select_button)

            # Add toolbar and canvas to the container
            self.verticalLayout_map.addWidget(self.map_toolbar)
            self.verticalLayout_map.addWidget(self.map_canvas)

            # Set map CRS to EPSG:3857 (Web Mercator for OSM)
            canvas_crs = QgsCoordinateReferenceSystem("EPSG:3857")
            self.map_canvas.setDestinationCrs(canvas_crs)

            # Show the widgets explicitly
            self.map_toolbar.show()
            self.map_canvas.show()
            self.map_canvas_container.show()

        # Setup map with target layer and OpenStreetMap
        # Create OpenStreetMap base layer
        osm_layer = self.create_osm_layer()

        # Set CRS to Web Mercator (EPSG:3857) for OSM compatibility
        self.map_canvas.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:3857"))

        # Set layers - target layer on top, OSM as base
        layers_to_display = [self.target_layer]
        if osm_layer and osm_layer.isValid():
            layers_to_display.append(osm_layer)

        # Clear existing layers and set new ones (same as page 3)
        self.map_canvas.setLayers([])
        self.map_canvas.setLayers(layers_to_display)

        # Get target layer extent and transform to EPSG:3857 if needed
        extent = self.target_layer.extent()
        if not extent.isNull() and not extent.isEmpty():
            # Transform extent to map CRS (EPSG:3857) if layer uses different CRS
            if self.target_layer.crs() != self.map_canvas.mapSettings().destinationCrs():
                transform = QgsCoordinateTransform(
                    self.target_layer.crs(),
                    self.map_canvas.mapSettings().destinationCrs(),
                    QgsProject.instance()
                )
                extent = transform.transformBoundingBox(extent)

            extent.scale(1.1)  # Add 10% buffer
            self.map_canvas.setExtent(extent)
        else:
            # Fallback to world extent in EPSG:3857
            extent = QgsRectangle(-20037508, -20037508, 20037508, 20037508)
            self.map_canvas.setExtent(extent)

        # Set white background
        self.map_canvas.setCanvasColor(Qt.white)

        # Enable rendering
        self.map_canvas.setRenderFlag(True)

        # Force the canvas to be visible
        self.map_canvas.show()
        self.map_canvas_container.show()

        # Force refresh
        self.map_canvas.refresh()
        QtWidgets.QApplication.processEvents()
        self.map_canvas.repaint()


        # Create and set the custom selection tool
        self.map_tool_select = FeatureSelectionTool(
            self.map_canvas,
            self.target_layer,
            self.update_selection_count
        )
        self.map_canvas.setMapTool(self.map_tool_select)

        # Connect to layer selection changed signal
        if self.target_layer:
            try:
                self.target_layer.selectionChanged.disconnect(self.update_selection_count)
            except:
                pass
            self.target_layer.selectionChanged.connect(self.update_selection_count)

        # Restore saved selection if user is coming back from page 3
        if saved_selection and len(saved_selection) > 0:
            self.target_layer.selectByIds(saved_selection)

        # Update selection count
        self.update_selection_count()

    def create_osm_layer(self):
        """Create an OpenStreetMap base layer.

        Note: This method is currently not used because OSM tiles don't render
        properly in custom QgsMapCanvas widgets outside the main QGIS window.
        This is a known limitation of QGIS when using secondary canvas widgets.

        Kept here for future reference or alternative implementations.

        Returns:
            QgsRasterLayer: The OSM layer, or None if creation failed
        """
        # OpenStreetMap XYZ tile service URL
        osm_url = "type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png&zmax=19&zmin=0&crs=EPSG:3857"

        # Create the raster layer with correct provider
        osm_layer = QgsRasterLayer(osm_url, "OpenStreetMap", "wms")

        # Check if the layer is valid
        if osm_layer.isValid():
            return osm_layer
        else:
            return None

    def get_target_layer(self):
        """Get the layer marked as 'Include as Target' from page 1."""
        for row in range(self.tableWidget_layers.rowCount()):
            combo = self.tableWidget_layers.cellWidget(row, 1)
            if combo and combo.currentText() == self.STATUS_TARGET:
                layer_name = self.tableWidget_layers.item(row, 0).text()
                # Find the layer in the project
                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers:
                    return layers[0]
        return None

    def select_all_features(self):
        """Select all features in the target layer."""
        if self.target_layer:
            self.target_layer.selectAll()
            self.update_selection_count()

    def clear_selection(self):
        """Clear all selected features in the target layer."""
        if self.target_layer:
            self.target_layer.removeSelection()
            self.update_selection_count()

    def update_selection_count(self):
        """Update the label showing the number of selected features."""
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            count = self.target_layer.selectedFeatureCount()
            self.label_selection_count.setText(f"Selected: {count} features")
            if self.map_canvas:
                self.map_canvas.refresh()

    def validate_page_2(self):
        """Validate page 2 before allowing user to proceed."""
        if not self.target_layer:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "No target layer is available."
            )
            return False

        # Check if at least one feature is selected
        if self.target_layer.selectedFeatureCount() == 0:
            QtWidgets.QMessageBox.warning(
                self,
                "Validation Error",
                "Please select at least one feature before proceeding."
            )
            return False

        # Create new layer with selected features
        selected_ids = list(self.target_layer.selectedFeatureIds())
        if selected_ids:
            # Check if we already have a layer with the same name and features
            expected_layer_name = f"{self.target_layer.name()}_selection"
            should_create_new = True

            # Check if selected_features_layer already exists and has the same features
            try:
                if self.selected_features_layer and self.selected_features_layer.isValid():
                    existing_ids = [f.id() for f in self.selected_features_layer.getFeatures()]
                    # Compare if the feature IDs match (sorted for comparison)
                    if sorted(existing_ids) == sorted(selected_ids):
                        # Same features, no need to create a new layer
                        should_create_new = False
            except RuntimeError:
                # Layer was deleted from QGIS, reset reference and create new one
                self.selected_features_layer = None
                should_create_new = True

            # Also check if a layer with this name already exists in the project
            if should_create_new:
                existing_layers = QgsProject.instance().mapLayersByName(expected_layer_name)
                for existing_layer in existing_layers:
                    if isinstance(existing_layer, QgsVectorLayer):
                        existing_ids = [f.id() for f in existing_layer.getFeatures()]
                        if sorted(existing_ids) == sorted(selected_ids):
                            # Found a layer with same name and same features, reuse it
                            self.selected_features_layer = existing_layer
                            should_create_new = False
                            break

            # Create new layer only if needed
            if should_create_new:
                # Remove old layer from project if it exists
                try:
                    if self.selected_features_layer and self.selected_features_layer.isValid():
                        QgsProject.instance().removeMapLayer(self.selected_features_layer.id())
                except RuntimeError:
                    # Layer was already deleted, that's fine
                    pass

                # Create the new layer
                if self.map_tool_select:
                    self.selected_features_layer = self.map_tool_select.create_layer_from_feature_id(
                        self.target_layer,
                        selected_ids
                    )

                    # Add the new layer to the project
                    if self.selected_features_layer and self.selected_features_layer.isValid():
                        QgsProject.instance().addMapLayer(self.selected_features_layer)

        return True

    def get_selected_features(self):
        """Get the list of selected feature IDs."""
        if self.target_layer:
            return list(self.target_layer.selectedFeatureIds())
        return []

    def detect_assessment_complexity(self):
        """Detect if this is a simple or complex assessment case.

        Returns:
            dict: A dictionary containing:
                - 'is_complex': bool - True if multiple layers require spatial operations
                - 'operation_type': str - Type of operation needed ('none', 'union', 'intersect', 'both')
                - 'included_layers': list - Layers marked as 'Include in assessment'
                - 'spatial_markers': list - Layers marked as 'Spatial Marker'
                - 'target_layer': QgsVectorLayer - The target layer
        """
        result = {
            'is_simple': False,
            'is_easy_complex': False,
            'is_super_complex': False,
            'operation_type': 'none',
            'included_layers': [],
            'spatial_markers': [],
            'target_layer': None,
            'requires_union': False,
            'requires_intersect': False
        }

        # Collect layers by status
        for row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(row, 0)
            status_combo = self.tableWidget_layers.cellWidget(row, 1)

            if layer_name_item and status_combo:
                layer_name = layer_name_item.text()
                status = status_combo.currentText()

                # Get the actual layer from QGIS project
                layers = QgsProject.instance().mapLayersByName(layer_name)
                if layers and isinstance(layers[0], QgsVectorLayer):
                    layer = layers[0]

                    if status == self.STATUS_TARGET:
                        result['target_layer'] = layer
                    elif status == self.STATUS_INCLUDE:
                        result['included_layers'].append(layer)
                    elif status == self.STATUS_SPATIAL_MARKER:
                        result['spatial_markers'].append(layer)

        # Determine complexity based on number of layers
        num_assessment_layers = len(result['included_layers'])
        num_spatial_markers = len(result['spatial_markers'])

        # Simple case: Only target layer, no additional assessment layers
        if num_assessment_layers == 0 and num_spatial_markers == 0:
            result['is_simple'] = True
            result['is_easy_complex'] = False
            result['is_super_complex'] = False
            result['operation_type'] = 'none'

        # Complex case: Multiple assessment layers require union/intersect operations
        elif num_assessment_layers == 1 and num_spatial_markers == 1:
            result['is_simple'] = False
            result['is_easy_complex'] = True
            result['is_super_complex'] = False

            # If we have included layers, we likely need union to combine them
            if num_assessment_layers >= 1:
                result['requires_union'] = True

            # If we have spatial markers, we might need intersect for filtering
            if num_spatial_markers > 0:
                result['requires_intersect'] = True
            # Determine operation type
            if result['requires_union'] and result['requires_intersect']:
                result['operation_type'] = 'both'   
            elif result['requires_union']:
                result['operation_type'] = 'union'
            elif result['requires_intersect']:
                result['operation_type'] = 'intersect'

        elif num_assessment_layers > 1 or num_spatial_markers > 1:
            result['is_simple'] = False
            result['is_easy_complex'] = False
            result['is_super_complex'] = True

            # Multiple assessment layers require union
            if num_assessment_layers > 1:
                result['requires_union'] = True
            # Multiple spatial markers require intersect
            if num_spatial_markers > 1:
                result['requires_intersect'] = True
            # Determine operation type
            if result['requires_union'] and result['requires_intersect']:
                result['operation_type'] = 'both'
            elif result['requires_union']:
                result['operation_type'] = 'union'
            elif result['requires_intersect']:
                result['operation_type'] = 'intersect'
        # Assessment layers only (no spatial markers)
        elif num_assessment_layers > 0 and num_spatial_markers == 0:
            result['is_simple'] = False
            result['is_easy_complex'] = True
            result['is_super_complex'] = False
            result['requires_union'] = True
            result['operation_type'] = 'union'

        # Spatial markers only (no assessment layers)
        elif num_spatial_markers > 0 and num_assessment_layers == 0:
            result['is_simple'] = False
            result['is_easy_complex'] = True
            result['is_super_complex'] = False
            result['requires_intersect'] = True
            result['operation_type'] = 'intersect'

        return result

    def get_assessment_summary(self):
        """Get a human-readable summary of the assessment complexity.

        Returns:
            str: Summary description of the assessment type
        """
        complexity = self.detect_assessment_complexity()

        # Simple case: Only target layer
        if complexity['is_simple']:
            return "Simple Assessment (Target layer only)"

        # Easy complex case: 1 assessment layer + 1 spatial marker
        if complexity['is_easy_complex']:
            summary_parts = ["Easy Complex Assessment:"]
            summary_parts.append(f"- 1 assessment layer to combine")
            summary_parts.append(f"- 1 spatial marker for filtering")

            if complexity['requires_union'] and complexity['requires_intersect']:
                summary_parts.append("- Union and Intersection operations required")
            elif complexity['requires_union']:
                summary_parts.append("- Union operation required")
            elif complexity['requires_intersect']:
                summary_parts.append("- Intersection operation required")

            return "\n".join(summary_parts)

        # Super complex case: Multiple assessment layers or spatial markers
        if complexity['is_super_complex']:
            summary_parts = ["Super Complex Assessment:"]

            if complexity['included_layers']:
                summary_parts.append(f"- {len(complexity['included_layers'])} assessment layer(s) to combine")

            if complexity['spatial_markers']:
                summary_parts.append(f"- {len(complexity['spatial_markers'])} spatial marker(s) for filtering")

            if complexity['requires_union'] and complexity['requires_intersect']:
                summary_parts.append("- Union and Intersection operations required")
            elif complexity['requires_union']:
                summary_parts.append("- Union operation required")
            elif complexity['requires_intersect']:
                summary_parts.append("- Intersection operation required")

            return "\n".join(summary_parts)

        # Default complex case (assessment layers or spatial markers only)
        summary_parts = ["Complex Assessment:"]

        if complexity['included_layers']:
            summary_parts.append(f"- {len(complexity['included_layers'])} assessment layer(s) to combine")

        if complexity['spatial_markers']:
            summary_parts.append(f"- {len(complexity['spatial_markers'])} spatial marker(s) for filtering")

        if complexity['operation_type'] != 'none':
            operation_desc = {
                'union': 'Union operation required',
                'intersect': 'Intersection operation required',
                'both': 'Union and Intersection operations required'
            }
            summary_parts.append(f"- {operation_desc.get(complexity['operation_type'], 'Spatial operations required')}")

        return "\n".join(summary_parts)

    def initialize_page_3(self):
        """Initialize the third wizard page."""
        # Set up the summary table headers
        self.tableWidget_summary_layers.setColumnCount(2)
        self.tableWidget_summary_layers.setHorizontalHeaderLabels(["Layer Name", "Status"])
        self.tableWidget_summary_layers.horizontalHeader().setStretchLastSection(True)

    def setup_page_3(self):
        """Populate page 3 with summary information."""
        # Get assessment name and description from page 1
        assessment_name = self.lineEdit_name.text().strip()
        assessment_description = self.textEdit_description.toPlainText().strip()

        # Update the summary labels
        self.label_summary_name.setText(assessment_name)
        self.label_summary_description.setText(assessment_description if assessment_description else "No description provided")

        # Detect assessment complexity and display information
        # complexity = self.detect_assessment_complexity()
        assessment_summary = self.get_assessment_summary()

        # Display complexity summary in the dedicated label
        self.label_complexity_summary.setText(assessment_summary)

        # Get selected feature count from target layer
        if self.target_layer and isinstance(self.target_layer, QgsVectorLayer):
            feature_count = self.target_layer.selectedFeatureCount()
            self.label_summary_features.setText(f"{feature_count} features selected")
        else:
            self.label_summary_features.setText("0 features selected")

        # Populate the layers table with all included layers
        self.tableWidget_summary_layers.setRowCount(0)

        row = 0
        for table_row in range(self.tableWidget_layers.rowCount()):
            layer_name_item = self.tableWidget_layers.item(table_row, 0)
            status_combo = self.tableWidget_layers.cellWidget(table_row, 1)

            if layer_name_item and status_combo:
                status = status_combo.currentText()

                # Only include layers that are not "Do not include"
                if status != self.STATUS_DO_NOT_INCLUDE:
                    self.tableWidget_summary_layers.insertRow(row)

                    # Add layer name
                    name_item = QTableWidgetItem(layer_name_item.text())
                    self.tableWidget_summary_layers.setItem(row, 0, name_item)

                    # Add status
                    status_item = QTableWidgetItem(status)
                    self.tableWidget_summary_layers.setItem(row, 1, status_item)

                    # Highlight the target layer
                    if status == self.STATUS_TARGET:
                        name_item.setBackground(Qt.gray)
                        status_item.setBackground(Qt.gray)

                    row += 1

        # Resize columns to content
        self.tableWidget_summary_layers.resizeColumnsToContents()

        # Create and setup map canvas for page 3 to show selected features
        if not self.map_canvas_page3:
            # Create map canvas with the container widget as parent
            self.map_canvas_page3 = QgsMapCanvas(self.widget_map_container_page3)
            self.map_canvas_page3.setCanvasColor(Qt.white)

            # Set size for the canvas
            self.map_canvas_page3.setMinimumSize(400, 400)
            self.map_canvas_page3.resize(800, 400)

            # Create or get the layout for the container widget
            if not self.widget_map_container_page3.layout():
                layout = QVBoxLayout(self.widget_map_container_page3)
                layout.setContentsMargins(0, 0, 0, 0)
            else:
                layout = self.widget_map_container_page3.layout()

            layout.addWidget(self.map_canvas_page3)

            # Set map CRS to EPSG:3857 (Web Mercator for OSM)
            canvas_crs = QgsCoordinateReferenceSystem("EPSG:3857")
            self.map_canvas_page3.setDestinationCrs(canvas_crs)

            # Show the widgets explicitly
            self.map_canvas_page3.show()
            self.widget_map_container_page3.show()
            self.groupBox_selected_features_map.show()

        # Display the selected features layer if it exists
        if self.selected_features_layer and self.selected_features_layer.isValid():
            # Create OpenStreetMap base layer
            osm_layer = self.create_osm_layer()

            # Set CRS to Web Mercator for OSM compatibility
            self.map_canvas_page3.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:3857"))

            # Get Spatial Marker layers from page 1 configuration
            spatial_marker_layers = []
            for table_row in range(self.tableWidget_layers.rowCount()):
                layer_name_item = self.tableWidget_layers.item(table_row, 0)
                status_combo = self.tableWidget_layers.cellWidget(table_row, 1)

                if layer_name_item and status_combo:
                    status = status_combo.currentText()

                    # Find layers with Spatial Marker status
                    if status == self.STATUS_SPATIAL_MARKER:
                        layer_name = layer_name_item.text()
                        layers = QgsProject.instance().mapLayersByName(layer_name)
                        if layers and isinstance(layers[0], QgsVectorLayer):
                            spatial_marker_layers.append(layers[0])

            # Set layers to display in order: selected features (top), spatial markers, OSM (base)
            # In QGIS, layers are rendered from bottom to top, so we add them in reverse order
            layers_to_display = []

            # 1. Selected features layer (will be on top - most visible)
            layers_to_display.append(self.selected_features_layer)

            # 2. Spatial Marker layers (middle)
            layers_to_display.extend(spatial_marker_layers)

            # 3. OSM base layer (bottom)
            if osm_layer and osm_layer.isValid():
                layers_to_display.append(osm_layer)

            # Clear existing layers and set new ones
            self.map_canvas_page3.setLayers([])
            self.map_canvas_page3.setLayers(layers_to_display)

            # Zoom to selected features layer extent
            layer_extent = self.selected_features_layer.extent()
            if not layer_extent.isNull() and not layer_extent.isEmpty():
                # Transform extent to map CRS (EPSG:3857) if needed
                if self.selected_features_layer.crs() != self.map_canvas_page3.mapSettings().destinationCrs():
                    transform = QgsCoordinateTransform(
                        self.selected_features_layer.crs(),
                        self.map_canvas_page3.mapSettings().destinationCrs(),
                        QgsProject.instance()
                    )
                    layer_extent = transform.transformBoundingBox(layer_extent)

                # Scale extent by 10% for better visibility
                layer_extent.scale(1.1)
                self.map_canvas_page3.setExtent(layer_extent)

            # Enable rendering and refresh canvas
            self.map_canvas_page3.setRenderFlag(True)
            self.map_canvas_page3.refresh()
            QtWidgets.QApplication.processEvents()
            self.map_canvas_page3.repaint()

    def zoom_in(self):
        """Zoom in on the map canvas."""
        if self.map_canvas:
            self.map_canvas.zoomIn()

    def zoom_out(self):
        """Zoom out on the map canvas."""
        if self.map_canvas:
            self.map_canvas.zoomOut()

    def zoom_to_layer(self):
        """Zoom to the extent of the target layer."""
        if self.map_canvas and self.target_layer:
            extent = self.target_layer.extent()
            if not extent.isNull() and not extent.isEmpty():
                # Transform extent to map CRS if needed
                if self.target_layer.crs() != self.map_canvas.mapSettings().destinationCrs():
                    transform = QgsCoordinateTransform(
                        self.target_layer.crs(),
                        self.map_canvas.mapSettings().destinationCrs(),
                        QgsProject.instance()
                    )
                    extent = transform.transformBoundingBox(extent)

                extent.scale(1.1)  # Add 10% buffer
                self.map_canvas.setExtent(extent)
                self.map_canvas.refresh()

    def toggle_pan(self):
        """Toggle pan mode for the map canvas."""
        if self.map_canvas:
            if self.pan_button.isChecked():
                # Uncheck rectangle select if it's checked
                if hasattr(self, 'rect_select_button') and self.rect_select_button.isChecked():
                    self.rect_select_button.setChecked(False)

                # Create pan tool if it doesn't exist
                if not hasattr(self, 'pan_tool'):
                    self.pan_tool = QgsMapToolPan(self.map_canvas)
                self.map_canvas.setMapTool(self.pan_tool)
            else:
                # Switch back to selection tool
                if self.map_tool_select:
                    self.map_canvas.setMapTool(self.map_tool_select)

    def toggle_rectangle_select(self):
        """Toggle rectangle selection mode for the map canvas."""
        if self.map_canvas:
            if self.rect_select_button.isChecked():
                # Uncheck pan if it's checked
                if hasattr(self, 'pan_button') and self.pan_button.isChecked():
                    self.pan_button.setChecked(False)

                # Always recreate the rectangle select tool to ensure it has the current target layer
                self.rect_select_tool = RectangleSelectTool(
                    self.map_canvas,
                    self.target_layer,
                    self.update_selection_count
                )
                self.map_canvas.setMapTool(self.rect_select_tool)
            else:
                # Switch back to point selection tool
                if self.map_tool_select:
                    self.map_canvas.setMapTool(self.map_tool_select)
